# 김민재
###### 202530204 


###### 10/30 강의
# 스택stack
---
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조 
* 데이터의 입력과 출력 순서는 후입선출
    * 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
* 푸시(push) : 스택에 데이터를 넣는 작업
* 팝 : 스택에서 데이터를 꺼내는 작업
* 꼭대기(top) : 푸시, 팝을 하는 위치
테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행 
* 바닥(bottom) : 스택의 가장 밑바닥 부분

# 스택의 구현 예
---
* 함수를 호출하고 실행할 떄 프로그램 내부에서는 스택을 사용
* 가장 먼저 main 함수를 실행하며 main 함수는 z 함수를 호출 
* 호출된 함수 z는 x 함수와 y함수를 순서대로 호출
* 함수를 호출할때는 푸시하고 함수가 실행을 종료하고 호출한 원래의 함수로 돌아갈 때는 종료할 함수를 팝함 
* main -> z -> x의 순서대로 함수를 호출
    * 이떄 스택의 상태는 호출한 함수의 역순으로 겹겹이 쌓여있어 함수 호출이 계층 구조로 이루어져 있음
    * 이 상태에서 x 함수의 실행이 종료되면 x 함수만 팝함

# 스택 구조체 IntStack
---
* 스택으로 사용할 배열을 가리키는 포인터 stk
    * 인덱스가 o인 요소를 스택의 바닥(bottom)이라 함
    * 배열의 메모리 공간 할당은 Initialize 함수로 생성
* 스택의 최대 용량 max
    * 배열 stk의 요소 개수와 같음
* 스택 포인터 ptr
    * 스택에 쌓여있는 데이터의 개수를 나타냄
    * 스택이 비어 있으면 ptr의 값은 0이고 가득 차있으면 max
    ![alt text](image.png)

# 실습 4-1
---
![alt text](image-1.png)

# 스택만들기 - (3)
* 초기화 함수 Initialize
    * 스택의 메모리 공간(배열)을 확보하는 등의 준비 작업을 수행하는 함수 
    * 1 배열을 위한 메모리 공간을 만들 떄 스택은 비어있어야(데이터가 하나도 쌓여 있지 않은 상태여야) 하므로 스택 포인터 ptr 값은 0으로 함
    * 2 요소의 개수가 max인 배열 stk를 생성함. 이때, 스택의 개별 요소에 접근하는 인덱스 식은 바닥(bottom)부터 stk[0], stk[1], ..., stk[max - 1]이 됨
    * 3 매개변수 max로 받은 값을 스택 최대 용령을 나타내는 구조체의 멤버 max에 저장
    ![alt text](image-3.png)

# 4-2 큐란?
---
**큐queue**
* 데이터를 일시적으로 쌓아두기 위한 자료구조
* 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조를 이룸
* 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열과 같음
* 인큐(en-queue): 큐에 데이터를 넣는 작업 
* 디큐(de-queue): 데이터를 꺼내는 작업
* 프런트(front): 데이터를 꺼내는 쪽
* 리어(rear): 데이터를 넣는 쪽

**배열로 큐 만들기**
* 큐의 구현 예
    * a 배열의 프런트(front)부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습
    * b 24 인큐 
        * 리어(rear)의 데이터가 저장된 que[3]의 다음 요소 que[4]에 24를 저장
        * 이 처리의 복잡도는 O(1) 이고 적은 비용으로 구현할 수 있음

    * c 19 디큐
        * que[0]에 저장된 19를 꺼낸 다음 두 번째 이후의 요소를 모두 맨 앞으로 옮김 
        * 이 처리의 복잡도는 O(n)이며 데이터를 꺼낼 때마다 이런 처리를 하게 되면 효율이 떨어짐
    ![alt text](image-6.png)

**링 버퍼로 큐 만들기 - (1)**
* 링 버퍼ribg buffer
    * 배열의 처음이 끝과 연결되었다고 보는 자료구조
    * 프런트(front): 논리적인 맨 처음 요소의 인덱스
    * 리어(rear) : 논리적인 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)
    * 변수 프런틔와 리어의 값은 인큐와 디큐를 수행함에 따라 변화하는데 이 때문에 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할 수 있음
    * 처리의 복잡도는 O(1)
    ![alt text](image-5.png)

**링 버퍼로 큐 만들기 - (2)**
* 링 버퍼에 대한 인큐와 디큐
    * a 7개의 데이터(35,56,24,68,95,73,19)가 차례대로 que[7] que[8], ..., que[11], que[0], que[1]에 저장
        * 프런트 값은 7이고 리어값은 2
    * b 82를 인큐한 다음의 상태
        * que[2](리어가 가리키고 있는 위치)에 82를 저장한 다음 리어값을 1만큼 증가
    * c 35를 디큐한 다음의 상태
        * 프런트 요소(que[front], 즉 que[7])의 값 35를 빼고 프런트 값을 1만큼 증가
        ![alt text](image-4.png)
        
**링 버퍼로 큐 만들기 - (12)**
* 모든 데이터를 출력하는 함수 print
    * 큐의 모든 데이터를 처음부터 끝까지 순서대로 출력하는 함수
* 종료 함수 Terminate
    * 메모리 공간에 할당한 배열(큐)을 해제하는 함수
    ![alt text](image-7.png)

1. Stock 후입 선출(Lifo)
2. queue 선입 선출(FiFo)
3. 원형 큐(링 버퍼 큐)
remi front 변수를 수정
        
        
###### 9/11 강의



###### 9/4  강의
[문자 크기](#h1에-해당) / [리스트](#리스트)
# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당

*이탤릭 체*
**볼드 체**

---
# 리스트
* 언오더드 리스트
* 언   
    * 탭
        * 탭2번
            * 탭3은 x

1. 오더드 리스트
4. 오더드 리스트

# 코드블럭 
```
int main 
```

인라인 코드블럭 예 : `<br>`, `ctrl` + `A`

외부링크 <br>
[google](https://google.com)

[내부링크](#h1)

[image](./20231027090450_wfludeql.png)